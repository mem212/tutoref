---
slug: "/unit-testing-best-practices/list/"
title: "Unit testing best practices"
sidebar_label: "List of best practices"
sidebar_position: 3
keywords:
    - Unit testing
    - Uni tests
    - Unit tests best practices
    - Unit testing best practices
    - Junit best practice
    - Trustworthy
    - Descriptive
    - Arrange Act Assert
    - AAA
    - Avoid Multi Acts
    - Test one thing
    - Isolation
    - Fast unit tests
    - Avoid logic in unt tests
    - Test only public methods
    - Maximum coverage
    - No Magic values tests units
    - Test edge cases


description: "Unit testing best practices. Unit tests best practices, Trustworthy, Descriptive, Arrange Act Assert, AAA. Avoid Multi Acts. Test one thing. Isolation. Fast unit tests. Avoid logic in unt tests. Test only public methods. Maximum coverage. No Magic values tests units. Test edge cases"
---


## Write trustworthy unit tests

A trustworthy unit test is a test you can trust. It means that it should fail when the code is broken, and succeed when - and only when - the code behaves like expected. 

If these two conditions are not met then our unit test is trustworthy.

>Â account bank, deposit 10,   assert account bank has money some money in it ,,, not enough, your method can add wrong number and the test will still be successful.


## Write descriptive unit tests

A unit test should be descriptive. If a colleague is reading your test case then he/she sould undestand, without spending much effort, what does the test try to validates and how, what is the expected result and under what conditions.

Naming unit tests has also an impact on their descriptiveness. In general, you should define or adopt an existing naming convention and stick to it.

There are many existing unit tests naming standards that you can follow and here are some of them:

- **UnitUnderTest_StateUnderTest_ExpectedBehavior**
  - This is a clean way to name your tests and makes them human readable. However you should consider renaming your unit tests if the name of unit under test changes.
  - You can also switch the StateUnderTest and the ExpectedBehavior.
- **Should_ExpectedBehavior_When_StateUnderTest**
  - This standard brings some redunduncy by having the term "Should" everywhere in your unit tests, but 
- **When_StateUnderTest_Expect_ExpectedBehavior**
  - You notice that this naming standard does not contain the UnitUnderTest name (method, class, etc). This is OK since we are testing a behavior.



Following are some examples using java / JUnit.

Consider a **calculateTotal()** method that calculates the total price of a list of products.

**bad examples**
```java
@Test
public void test1(){
    // this is the worse name you can give to your unit test    
}

@Test
public void testCalculateTotal(){
    // This is too general and doesn't tell the expected behavior
    // under what conditions    
}

```
**A few naming models**

**good example**

```java
@Test
public void calcluateTotal_Should_Return_Zero_When_No_Products(){
    // some code ...
}

```

There are many ...
[UnitOfWork_StateUnderTest_ExpectedBehavior]

The Should
Should_ExpectedBehavior_When_StateUnderTest



In addition to the above, coding conventions and programming best practices that you put in practice when developing production code still apply when you write unit tests.
 This will make your unit tests more readable and clean.

## Arrange Act Assert

Arrange-Act-Assert AAA = Arrange Act Assert = well structured


## Avoid multiple acts

talk about multiple assertions

## Test one thing at a time

talk about multiple assertions

Test a single unit of code

## Write isolated unit tests

talk about multiple assertions

## Write fast unit tests

## Avoid logic in unit tests

## Test public methods

Validate private methods using public methods. Test only public methods.

## Cover the maximum you can

	types of coverage
		line + branch
		https://dzone.com/articles/unit-testing-best-practices-how-to-get-the-most-ou

## Avoid magic values

## No side effects

## Test edge cases

## Learn your testing framework

